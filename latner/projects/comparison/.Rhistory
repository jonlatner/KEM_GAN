data <- rbind(data,tmp_dataset)
tmp_variables <- c("persnr", "syear", "xp40")
tmp_dataset <- readRDS(file.path(path_in, "xp.rds"))
tmp_dataset <- tmp_dataset[ , tmp_variables]
names(tmp_dataset)[3] <- "public"
data <- rbind(data,tmp_dataset)
tmp_variables <- c("persnr", "syear",  "bbp32")
tmp_dataset <- readRDS(file.path(path_in, "bbp.rds"))
tmp_dataset <- tmp_dataset[ , tmp_variables]
names(tmp_dataset)[3] <- "public"
data <- rbind(data,tmp_dataset)
tmp_variables <- c("persnr", "syear",  "pp33")
tmp_dataset <- readRDS(file.path(path_in, "pp.rds"))
tmp_dataset <- tmp_dataset[ , tmp_variables]
names(tmp_dataset)[3] <- "public"
data <- rbind(data,tmp_dataset)
tmp_variables <- c("persnr", "syear",  "jp36")
tmp_dataset <- readRDS(file.path(path_in, "jp.rds"))
tmp_dataset <- tmp_dataset[ , tmp_variables]
names(tmp_dataset)[3] <- "public"
data <- rbind(data,tmp_dataset)
tmp_variables <- c("persnr", "syear",  "op3101")
tmp_dataset <- readRDS(file.path(path_in, "op.rds"))
tmp_dataset <- tmp_dataset[ , tmp_variables]
names(tmp_dataset)[3] <- "public"
data <- rbind(data,tmp_dataset)
tmp_variables <- c("persnr", "syear",  "bep36")
tmp_dataset <- readRDS(file.path(path_in, "bep.rds"))
tmp_dataset <- tmp_dataset[ , tmp_variables]
names(tmp_dataset)[3] <- "public"
data <- rbind(data,tmp_dataset)
tmp_variables <- c("persnr", "syear",  "bip_68")
tmp_dataset <- readRDS(file.path(path_in, "bip.rds"))
tmp_dataset <- tmp_dataset[ , tmp_variables]
names(tmp_dataset)[3] <- "public"
data <- rbind(data,tmp_dataset)
tmp_variables <- c("persnr", "syear", "ip36")
tmp_dataset <- readRDS(file.path(path_in, "ip.rds"))
tmp_dataset <- tmp_dataset[ , tmp_variables]
names(tmp_dataset)[3] <- "public"
data <- rbind(data,tmp_dataset)
tmp_variables <- c("persnr", "syear",  "rp34")
tmp_dataset <- readRDS(file.path(path_in, "rp.rds"))
tmp_dataset <- tmp_dataset[ , tmp_variables]
names(tmp_dataset)[3] <- "public"
data <- rbind(data,tmp_dataset)
tmp_variables <- c("persnr", "syear", "bfp59")
tmp_dataset <- readRDS(file.path(path_in, "bfp.rds"))
tmp_dataset <- tmp_dataset[ , tmp_variables]
names(tmp_dataset)[3] <- "public"
data <- rbind(data,tmp_dataset)
tmp_variables <- c("persnr", "syear",  "qp31")
tmp_dataset <- readRDS(file.path(path_in, "qp.rds"))
tmp_dataset <- tmp_dataset[ , tmp_variables]
names(tmp_dataset)[3] <- "public"
data <- rbind(data,tmp_dataset)
tmp_variables <- c("persnr", "syear",  "zp33")
tmp_dataset <- readRDS(file.path(path_in, "zp.rds"))
tmp_dataset <- tmp_dataset[ , tmp_variables]
names(tmp_dataset)[3] <- "public"
data <- rbind(data,tmp_dataset)
tmp_variables <- c("persnr", "syear", "bdp47")
tmp_dataset <- readRDS(file.path(path_in, "bdp.rds"))
tmp_dataset <- tmp_dataset[ , tmp_variables]
names(tmp_dataset)[3] <- "public"
data <- rbind(data,tmp_dataset)
### DONE ###
save(data, file=file.path(path_out, "publicsector.rds"))
tmp_variables <- c("persnr", "syear", vars_public[[v]])
# List of file prefixes and corresponding variable names
vars_public <- list("sp34", "bap31", "bgp55", "vp36", "up31", "wp29", "hp36", "kp48", "bcp32", "yp39", "lp39", "mp3701", "bhp_58", "np3101", "tp60", "xp40", "bbp32", "pp33", "jp36", "op3101", "bep36", "bip_68", "ip36", "rp34", "bfp59", "qp31", "zp33", "bdp47")
# Loop through each file and variable pair
for (v in vars_public) {
tmp_variables <- c("persnr", "syear", vars_public[[v]])
tmp_dataset <- readRDS(file.path(path_in, paste0(file_prefix, ".rds")))
tmp_dataset <- tmp_dataset[ , tmp_variables]
names(tmp_dataset)[3] <- "public"
data <- rbind(data, tmp_dataset)
}
# --------------------------------------------------------------------.
# This command file was generated by paneldata.org                    .
# --------------------------------------------------------------------.
# !!! I M P O R T A N T - W A R N I N G !!!                           .
# You alone are responsible for contents and appropriate.             .
# usage by accepting the usage agreement.                             .
# --------------------------------------------------------------------.
# Please report any errors of the code generated here                 .
# to soepmail@diw.de                                                  .
# --------------------------------------------------------------------.
# Top commands --------------------------------------------------------------
# https://stackoverflow.com/questions/7505547/detach-all-packages-while-working-in-r
detachAllPackages <- function() {
basic.packages <- c("package:stats","package:graphics","package:grDevices","package:utils","package:datasets","package:methods","package:base")
package.list <- search()[ifelse(unlist(gregexpr("package:",search()))==1,TRUE,FALSE)]
package.list <- setdiff(package.list,basic.packages)
if (length(package.list)>0)  for (package in package.list) detach(package, character.only=TRUE)
}
detachAllPackages()
rm(list=ls(all=TRUE))
path_in = "OneDrive/SECCOPA/data/DE_SOEP/raw_data/R"
path_out = "OneDrive/ftc_trends_de/data_files/"
# READ DATA ----
# Initialize an empty data frame
data <- data.frame()
# List of file prefixes and corresponding variable names
files_and_vars <- list(
sp = "sp34", bap = "bap31", bgp = "bgp55", vp = "vp36", up = "up31",
wp = "wp29", hp = "hp36", kp = "kp48", bcp = "bcp32", yp = "yp39",
lp = "lp39", mp = "mp3701", bhp = "bhp_58", np = "np3101", tp = "tp60",
xp = "xp40", bbp = "bbp32", pp = "pp33", jp = "jp36", op = "op3101",
bep = "bep36", bip = "bip_68", ip = "ip36", rp = "rp34", bfp = "bfp59",
qp = "qp31", zp = "zp33", bdp = "bdp47"
)
# Loop through each file and variable pair
for (file_prefix in names(files_and_vars)) {
tmp_variables <- c("persnr", "syear", files_and_vars[[file_prefix]])
tmp_dataset <- readRDS(file.path(path_in, paste0(file_prefix, ".rds")))
tmp_dataset <- tmp_dataset[ , tmp_variables]
names(tmp_dataset)[3] <- "public"
data <- rbind(data, tmp_dataset)
}
### Save ###
save(data, file=file.path(path_out, "publicsector.rds"))
sqrt(45/5)
sqrt(45/4)
# Load required packages
if (!require("lmtest")) {
install.packages("lmtest")
}
if (!require("sandwich")) {
install.packages("sandwich")
}
library(lmtest)
library(sandwich)
# Simulate some data
set.seed(123)
n <- 1000
age <- rnorm(n, mean = 40, sd = 10)
gender <- sample(c(0, 1), n, replace = TRUE)  # 0 for female, 1 for male
education <- rnorm(n, mean = 16, sd = 2)  # years of education
wages <- 20 + 0.5 * age + 2 * gender + 1.5 * education + rnorm(n, mean = 0, sd = 5)
# Step 1: Fit a basic OLS regression
model1 <- lm(wages ~ age + gender + education)
summary(model1)
# Step 2: Extract residuals from the OLS model
residuals_model1 <- resid(model1)
# Step 3: Fit a second model where the squared residuals are regressed on the same variables
# This models the conditional variance of wages as a function of the independent variables
residuals_squared <- residuals_model1^2
model2 <- lm(residuals_squared ~ age + gender + education)
# Step 4: Use heteroskedasticity-consistent standard errors
coeftest(model2, vcov = vcovHC(model2, type = "HC1"))
# Summary of the second stage model
summary(model2)
# Summary of the second stage model
summary(model2)
summary(model1)
# Load required packages
if (!require("lmtest")) {
install.packages("lmtest")
}
if (!require("sandwich")) {
install.packages("sandwich")
}
library(lmtest)
library(sandwich)
# Simulate some data
set.seed(123)
n <- 1000
age <- rnorm(n, mean = 40, sd = 10)
gender <- sample(c(0, 1), n, replace = TRUE)  # 0 for female, 1 for male
# Create a categorical variable for education with 3 levels
education_cont <- rnorm(n, mean = 16, sd = 2)  # original continuous education variable
# Convert the continuous education into a categorical variable with 3 levels
education <- cut(education_cont,
breaks = c(-Inf, 12, 16, Inf),
labels = c("Low", "Medium", "High"))
# Make sure education is a factor
education <- factor(education, levels = c("Low", "Medium", "High"))
# Simulate wages based on age, gender, and education categories
wages <- 20 + 0.5 * age + 2 * gender + ifelse(education == "Low", 0, ifelse(education == "Medium", 3, 5)) + rnorm(n, mean = 0, sd = 5)
# Step 1: Fit a basic OLS regression
model1 <- lm(wages ~ age + gender + education)
summary(model1)
# Step 2: Extract residuals from the OLS model
residuals_model1 <- resid(model1)
# Step 3: Fit a second model where the squared residuals are regressed on the same variables
# This models the conditional variance of wages as a function of the independent variables
residuals_squared <- residuals_model1^2
model2 <- lm(residuals_squared ~ age + gender + education)
# Step 4: Use heteroskedasticity-consistent standard errors
coeftest(model2, vcov = vcovHC(model2, type = "HC1"))
# Summary of the second stage model
summary(model2)
library(texreg)
library(lmtest)
library(sandwich)
# Simulate some data
set.seed(123)
n <- 1000
age <- rnorm(n, mean = 40, sd = 10)
gender <- sample(c(0, 1), n, replace = TRUE)  # 0 for female, 1 for male
# Create a categorical variable for education with 3 levels
education_cont <- rnorm(n, mean = 16, sd = 2)  # original continuous education variable
# Convert the continuous education into a categorical variable with 3 levels
education <- cut(education_cont,
breaks = c(-Inf, 12, 16, Inf),
labels = c("Low", "Medium", "High"))
# Make sure education is a factor
education <- factor(education, levels = c("Low", "Medium", "High"))
# Simulate wages based on age, gender, and education categories
wages <- 20 + 0.5 * age + 2 * gender + ifelse(education == "Low", 0, ifelse(education == "Medium", 3, 5)) + rnorm(n, mean = 0, sd = 5)
# Step 1: Fit a basic OLS regression (Model 1)
model1 <- lm(wages ~ age + gender + education)
summary(model1)
# Step 2: Extract residuals from the OLS model
residuals_model1 <- resid(model1)
# Step 3: Fit a second model (Model 2) where the squared residuals are regressed on the same variables
residuals_squared <- residuals_model1^2
model2 <- lm(residuals_squared ~ age + gender + education)
# Step 4: Calculate heteroskedasticity-consistent (robust) standard errors for Model 2
robust_se_model2 <- sqrt(diag(vcovHC(model2, type = "HC1")))
# Step 5: Use texreg to compare Model 1 and Model 2
# In texreg, you can manually input the robust standard errors for Model 2
screenreg(list(model1, model2),
override.se = list(coef(summary(model1))[, "Std. Error"], robust_se_model2),
override.pvalues = list(coef(summary(model1))[, "Pr(>|t|)"],
2 * pt(abs(coef(model2) / robust_se_model2), df = model2$df.residual, lower.tail = FALSE)),
custom.model.names = c("Model 1: Wages", "Model 2: Squared Residuals"))
# Load required packages
if (!require("texreg")) {
install.packages("texreg")
}
if (!require("lmtest")) {
install.packages("lmtest")
}
if (!require("sandwich")) {
install.packages("sandwich")
}
library(texreg)
library(lmtest)
library(sandwich)
# Simulate some data
set.seed(123)
n <- 1000
age <- rnorm(n, mean = 40, sd = 10)
gender <- sample(c(0, 1), n, replace = TRUE)  # 0 for female, 1 for male
# Create a categorical variable for education with 3 levels
education_cont <- rnorm(n, mean = 16, sd = 2)  # original continuous education variable
education <- cut(education_cont,
breaks = c(-Inf, 12, 16, Inf),
labels = c("Low", "Medium", "High"))
education <- factor(education, levels = c("Low", "Medium", "High"))
# Simulate contract type (0 = Temporary, 1 = Permanent)
# Higher age, male gender, and higher education should increase the probability of having a permanent contract
logit_p <- -1 + 0.05 * age + 0.7 * gender + ifelse(education == "Low", 0, ifelse(education == "Medium", 1, 2))
prob_permanent <- exp(logit_p) / (1 + exp(logit_p))
contract_type <- rbinom(n, 1, prob_permanent)  # 1 for permanent, 0 for temporary
# Step 1: Fit a logistic regression model (Model 1)
model1 <- glm(contract_type ~ age + gender + education, family = binomial)
summary(model1)
# Step 2: Extract residuals from the logistic model
# For logistic regression, we use Pearson residuals to check variance
residuals_model1 <- residuals(model1, type = "pearson")
# Step 3: Fit a second model where the squared residuals are regressed on the same variables
residuals_squared <- residuals_model1^2
model2 <- lm(residuals_squared ~ age + gender + education)
# Step 4: Calculate heteroskedasticity-consistent (robust) standard errors for Model 2
robust_se_model2 <- sqrt(diag(vcovHC(model2, type = "HC1")))
# Step 5: Use texreg to compare Model 1 and Model 2
# We use robust standard errors for Model 2
screenreg(list(model1, model2),
override.se = list(coef(summary(model1))[, "Std. Error"], robust_se_model2),
override.pvalues = list(coef(summary(model1))[, "Pr(>|z|)"],
2 * pt(abs(coef(model2) / robust_se_model2), df = model2$df.residual, lower.tail = FALSE)),
custom.model.names = c("Model 1: Logistic Regression (Permanent Contract)",
"Model 2: Squared Residuals Regression"))
# Load required packages
if (!require("texreg")) {
install.packages("texreg")
}
if (!require("lmtest")) {
install.packages("lmtest")
}
if (!require("sandwich")) {
install.packages("sandwich")
}
library(texreg)
library(lmtest)
library(sandwich)
# Simulate some data
set.seed(123)
n <- 1000
age <- rnorm(n, mean = 40, sd = 10)
gender <- sample(c(0, 1), n, replace = TRUE)  # 0 for female, 1 for male
# Create a categorical variable for education with 3 levels
education_cont <- rnorm(n, mean = 16, sd = 2)  # original continuous education variable
education <- cut(education_cont,
breaks = c(-Inf, 12, 16, Inf),
labels = c("Low", "Medium", "High"))
education <- factor(education, levels = c("Low", "Medium", "High"))
# Simulate contract type (0 = Temporary, 1 = Permanent)
# Higher age, male gender, and higher education should increase the probability of having a permanent contract
logit_p <- -1 + 0.05 * age + 0.7 * gender + ifelse(education == "Low", 0, ifelse(education == "Medium", 1, 2))
prob_permanent <- exp(logit_p) / (1 + exp(logit_p))
contract_type <- rbinom(n, 1, prob_permanent)  # 1 for permanent, 0 for temporary
# Step 1: Fit a logistic regression model (Model 1)
model1 <- glm(contract_type ~ age + gender + education, family = binomial)
summary(model1)
# Step 2: Extract residuals from the logistic model
# For logistic regression, we use Pearson residuals to check variance
residuals_model1 <- residuals(model1, type = "pearson")
# Step 3: Fit a second model where the squared residuals are regressed on the same variables
residuals_squared <- residuals_model1^2
model2 <- lm(residuals_squared ~ age + gender + education)
# Step 4: Calculate heteroskedasticity-consistent (robust) standard errors for Model 2
robust_se_model2 <- sqrt(diag(vcovHC(model2, type = "HC1")))
# Step 5: Use texreg to compare Model 1 and Model 2
# We use robust standard errors for Model 2
screenreg(list(model1, model2),
override.se = list(coef(summary(model1))[, "Std. Error"], robust_se_model2),
override.pvalues = list(coef(summary(model1))[, "Pr(>|z|)"],
2 * pt(abs(coef(model2) / robust_se_model2), df = model2$df.residual, lower.tail = FALSE)),
custom.model.names = c("Model 1: Logistic Regression (Permanent Contract)",
"Model 2: Squared Residuals Regression"))
reticulate::repl_python()
reticulate::repl_python()
# Top commands ----
# Create empty R application (no figures, data frames, packages, etc.)
# Get a list of all loaded packages
packages <- search()[grepl("package:", search())]
# Unload each package
for (package in packages) {
unloadNamespace(package)
}
rm(list=ls(all=TRUE))
# load library
library(synthpop)
library(tidyverse)
library(xtable)
# FOLDERS - ADAPT THIS PATHWAY
main_dir = "/Users/jonathanlatner/Documents/GitHub/KEM_GAN/latner/projects/comparison/"
data_files = "data_files/"
tables = "tables/"
original_data = "data_files/original/"
synthetic_data = "data_files/synthetic/synthpop/"
setwd(main_dir)
#functions
options(scipen=999)
# Function to generate a summary for a data frame
summary_df <- function(data) {
summary_matrix <- matrix(NA,
nrow = ncol(data),
ncol = 5,
dimnames = list(names(data), c("Type","Observations","Unique Values", "Missings","Negative values")))
for (col in names(data)) {
summary_matrix[col, "Type"] <- class(data[[col]])
summary_matrix[col, "Observations"] <- length(data[[col]])
summary_matrix[col, "Unique Values"] <- length(unique(data[[col]]))
summary_matrix[col, "Missings"] <- sum(is.na(data[[col]]))
summary_matrix[col, "Negative values"] <- sum(data[[col]]<0,na.rm = TRUE)
}
summary_df <- as.data.frame(summary_matrix)
return(summary_df)
}
# Create fake synthetic data ----
ods <- SD2011
write.csv(ods, paste0(original_data,"sd2011.csv"), row.names = FALSE)
ods <- SD2011
ods[ods < 0] <- NA
ods[ods == ""] <- NA
ods <- ods %>%
mutate_if(is.character, as.factor)
write.csv(ods, paste0(original_data,"sd2011_clean.csv"), row.names = FALSE)
ods <- SD2011
ods[ods < 0] <- NA
ods[ods == ""] <- NA
ods <- ods %>%
mutate_if(is.character, as.factor)
ods$agegr <- NULL
ods$bmi <- NULL
write.csv(ods, paste0(original_data,"sd2011_clean_small.csv"), row.names = FALSE)
ods <- SD2011
ods[ods < 0] <- NA
ods[ods == ""] <- NA
ods <- ods %>%
mutate_if(is.character, as.factor)
ods$agegr <- NULL
ods$bmi <- NULL
ods <- ods %>%
select(-eduspec, eduspec)  %>%
select(where(is.factor))
write.csv(ods, paste0(original_data,"sd2011_clean_small_categorical.csv"), row.names = FALSE)
ods <- SD2011
ods[ods < 0] <- NA
ods[ods == ""] <- NA
ods <- ods %>%
mutate_if(is.character, as.factor)
ods$agegr <- NULL
ods$bmi <- NULL
ods <- ods %>%
select(-eduspec, eduspec)  %>%
select(where(is.numeric))
write.csv(ods, paste0(original_data,"sd2011_clean_small_numeric.csv"), row.names = FALSE)
# Summary table ----
ods <- SD2011
ods[ods == ""] <- NA
ods$wkabdur <- as.numeric(ods$wkabdur)
summary(ods)
# Use the function with simulated data
df_data_structure <- data.frame(summary_df(ods))
df_data_structure$Variable <- rownames(df_data_structure)
rownames(df_data_structure) <- NULL  # Remove row names
df_data_structure$Description = c(
"Sex",
"Age of person, 2011",
"Age group, 2011",
"Category of the place of residence",
"Region (voivodeship)",
"Highest educational qualification, 2011",
"Discipline of completed qualification",
"Socio-economic status, 2011",
"Total duration of unemployment in the last 2 years (in months)",
"Personal monthly net income",
"Marital status",
"Month of marriage",
"Year of marriage",
"Month of separation/divorce",
"Year of separation/divorce",
"Perception of life as a whole",
"Depression symptoms indicator",
"View on interpersonal trust",
"Trust in own family members",
"Trust in neighbours",
"Active engagement in some form of sport or exercise",
"Number of friends",
"Smoking cigarettes",
"Number of cigarettes smoked per day",
"Drinking too much alcohol",
"Starting to use alcohol to cope with troubles",
"Working abroad in 2007-2011 (in months)",
"Total time spent on working abroad",
"Plans to go abroad to work in the next two years",
"Intended duration of working abroad",
"Intended destination country",
"Knowledge of English language",
"Height of person",
"Weight of person",
"Body mass index (weight - kg/(height - cm$^2$)*10000)"
)
df_data_structure <- df_data_structure %>%
mutate(Number = row_number()) %>%
select(Number, Variable,Description,everything()) %>%
mutate(Negative.values = ifelse(Type == "factor", yes = 0, no = Negative.values),
Generated = ifelse((Variable == "bmi" | Variable == "agegr"), yes = "Yes", no = NA),
Messy = ifelse((Variable == "nociga" | Variable == "agegr" | Variable == "bmi" | Variable == "wkabdur" | Variable == "nofriend" | Variable == "income"), yes = "Yes", no = NA))
# Print the data frame as a LaTeX table using xtable
latex_table <- xtable(df_data_structure)
print.xtable(latex_table,
include.rownames = FALSE,
sanitize.text.function = identity,
floating = FALSE,
booktabs = TRUE,
file = paste0(tables,"table_sd2011_data_structure.tex"))
# Summary table (small) ----
df_data_structure_small <- df_data_structure
# Replace rows 29 to 32
df_data_structure_small <- df_data_structure_small[-c(30:32), ]
df_data_structure_small[29, seq(1, 4, 1)] <- NA       # Set the first and second columns to NA
df_data_structure_small[29, 5] <- "\\dots"           # Set the third column to "..."
df_data_structure_small[29, seq(6, 10, 1)] <- NA        # Set the last two columns to NA
# Replace rows 25 to 26
df_data_structure_small <- df_data_structure_small[-c(26:27), ]
df_data_structure_small[25, seq(1, 4, 1)] <- NA       # Set the first and second columns to NA
df_data_structure_small[25, 5] <- "\\dots"           # Set the third column to "..."
df_data_structure_small[25, seq(6, 10, 1)] <- NA        # Set the last two columns to NA
# Replace rows 16 to 21
df_data_structure_small <- df_data_structure_small[-c(17:21), ]
df_data_structure_small[16, seq(1, 4, 1)] <- NA       # Set the first and second columns to NA
df_data_structure_small[16, 5] <- "\\dots"           # Set the third column to "..."
df_data_structure_small[16, seq(6, 10, 1)] <- NA        # Set the last two columns to NA
# Replace rows 8 to 10
df_data_structure_small <- df_data_structure_small[-c(9, 13), ]
df_data_structure_small[8, seq(1, 4, 1)] <- NA       # Set the first and second columns to NA
df_data_structure_small[8, 5] <- "\\dots"           # Set the third column to "..."
df_data_structure_small[8, seq(6, 10, 1)] <- NA        # Set the last two columns to NA
# Print the data frame as a LaTeX table using xtable
latex_table <- xtable(df_data_structure_small)
print.xtable(latex_table,
include.rownames = FALSE,
sanitize.text.function = identity,
floating = FALSE,
booktabs = TRUE,
file = paste0(tables,"table_sd2011_data_structure_small.tex"))
# Extra ----
# Count the number of factor variables
num_factor_variables <- sum(sapply(ods, is.factor))
# Count the number of numeric variables
num_numeric_variables <- sum(sapply(ods, is.numeric))
# Print the results
cat("Number of factor variables:", num_factor_variables, "\n")
cat("Number of numeric variables:", num_numeric_variables, "\n")
# Quirky variables
# BMI (1 individual with bmi, but missing weight)
df_bmi_missing <- ods %>%
select(height, weight, bmi) %>%
filter(is.na(height) | is.na(weight))
df_bmi_missing %>% filter(!is.na(bmi))
# Age group
with(ods,table(agegr,age,useNA = "ifany"))
# Smoking / number of cigaretes per day
with(ods,table(smoke,nociga))
